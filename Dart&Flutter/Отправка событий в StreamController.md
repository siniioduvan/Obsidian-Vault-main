#Dart #Flutter #stream 

Выше мы рассмотрели все способы создания двух типов `Stream`: с одним подписчиком (`single-subscription`) и широковещательные (`broadcast`).

Если с созданием `Stream` через конструктор и через генератор всё ясно (события в момент подписки доходят до обработчика сразу), то для `StreamController` есть специальный механизм — [`Sink`](https://api.flutter.dev/flutter/dart-core/Sink-class.html).

Предназначение `Sink` — точка входа для данных в потоке.

У `Sink` есть множество реализаций в Dart, но мы остановимся на `StreamSink` — класс, который может принимать данные для Stream синхронно и асинхронно (как именно — определяет реализация `StreamController`).

Теперь рассмотрим доступные методы `Sink`, для лучшего понимания, советую открыть реализацию этого класса или его сигнатуру в [документации](https://api.flutter.dev/flutter/dart-async/StreamSink-class.html).

Доступно всего несколько методов:

Наследование от `EventSink<S>`:

- `addEvent(S event)` — добавляет новое событие в `Stream`, затем `StreamController` передает его всем активным подписчикам.
- `addError(Object error)` — добавляет ошибку в `Stream`. Отловить ее можно с помощью`handleError()` в месте подписки.

Наследование от `StreamConsumer<S>`:

- `addStream(Stream<S> stream)` — берет все события из `stream` и передает в `StreamController`. Возвращает `Future`.

Наследование от `Sink`:

- `close` — Сообщить `Sink`, что новых событий для этого инстанса больше не будет. Если попытаетесь что-то добавить в закрытый `Sink` , вы получите ошибку.

И лишь одно свойство:

- `done` — Это `Future`, которая выполнится, если `StreamSink`закрыт или один из методов `EventSink` выстрелил исключение.
*************
Пока выполняется `Future` из `addStream()`, нельзя пользоваться методами `EventSink`. Иначе вы получите исключение.
******************

