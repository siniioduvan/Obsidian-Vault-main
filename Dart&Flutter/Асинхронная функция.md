#Dart #Flutter #future 

Повторим определение:

- Асинхронная операция: Некая работа, которая может позволять другим операциям выполняться после её старта и вплоть до завершения.
- Асинхронная функция: Функция, которая выполняет **как минимум одну** асинхронную операцию и неограниченное кол-во синхронных операций.

Чтобы превратить синхронную функцию в асинхронную достаточно добавить ключевое слово `async` перед телом функции:

```dart
void myAsyncFunction() async {
		print('Some job');
}
```

Поздравляю, теперь вызов `myAsyncFunction()` — асинхронная операция.

Пробуем:

```dart
void main() {
  print('Before operation');
  foo();
  print('After operation');
}

void foo() async {
  print('async');
}
```

Что-то не то, `foo()` же асинхронная, она не должна была блокировать вызов `print('After operation')`

На самом деле, функции помеченные `async` выполняются синхронно, до тех пор, пока не встретят первое применение ключевого слова `await`

Для полного понимания, давайте расширим понятие асинхронной функции:

Это функция, выполнение которой может быть приостановлено с передачей управления назад в место вызова. Как только блокирующая операция выполнится, выполнение функции продолжится с места, где она была приостановлена.

Ключевое слово `await` как раз позволяет приостановить исполнение кода.

Несколько важных замечаний:

1. `await` можно использовать только внутри функции, помеченной `async`.
2. Мы можем дождаться только выполнения `Future`.
3. Асинхронная функция может возвращать значения только типа `Future`.
4. Возвращаемым значением асинхронной функции может быть `void`, но в таком случае мы не сможем дождаться ее выполнения

Давайте модифицируем предыдущий пример. Не торопитесь запускать, попробуйте сами предугадать результат:

```dart
void main() {
  print('Before operation');
  getAsyncJobValue().then((value) => print("Go async value: $value"));
  print('After operation');
}

Future<int> getAsyncJobValue() async {
  print('Sync inside async');
  await Future(()=> print('Awaited async job'));
  return Future.value(5);
}
```

Вот теперь действительно все сошлось:

- асинхронная `getAsyncJobValue()` была вызвана;
- код начал исполняться синхронно;
- на 9-й строке `await` поставило на паузу выполнение `getAsyncJobValue()`, но не заблокировало выполнение `main()`;
- как только `Future` на 9-й строке завершил свою работу, код пошёл дальше.

Прежде чем двинуться дальше, коротко напомним, что мы узнали:

1. Асинхронной функцию можно сделать с помощью ключевого слова `async`, но код будет выполняться асинхронно только после `await`
2. `Future` — не операция вовсе, а вот функция внутри него уже может быть синхронной или асинхронной.
3. `Event Loop` — это бесконечный цикл обработки событий, он позволяет достичь псевдопаралелизма