#Dart #Flutter #future 

В блоке про `Future` мы уже приводили примеры кода, которые позволяют не блокировать исполнение кода.

Это не совсем так:

Как выполнится код `Future` внутри EventLoop зависит от того, какая функция была передана внутрь `Future` — синхронная или асинхронная.

Синхронные оперции могут заблокировать выполнение дальнейшего кода, потому что Event Loop не пойдет на новый цикл, пока не обработает такую операцию.

Получается, что `Future` позволяет делать мнимые асинхронные операции, порядок выполнения которых на деле зависит от функции, переданной в конструкторе `Future`.

Для окончательного понимания давайте рассмотрим следующий код:
```dart
print('Before Future');
Future(()=> print('Future')).then((_)=> print('Future then'));
print('After Future');
```

Порядок вывода будет следующий: 'Before Future' → 'AfterFuture' → 'Future' -> 'Future then'

Это верно, но на деле вызов будет следующим

![fluttern_1.2.3_3.svg](https://yastatic.net/s3/ml-handbook/admin/fluttern_1_2_3_3_02dea5d20e.svg)

Такой порядок будет верен всегда, так что:

1. `Future` не является настоящей асинхронной операцией. И `Future` , и код внутри сами по себе — синхронные операции.
2. `Future` не является легковесной реализацией параллелизма. Если бы это было правдой, мы не смогли бы гарантировать, что `‘After Future’` выведется раньше `‘Future’`
