#Dart #Flutter #stream 

Мы сказали, что `SynchronousStreamController` стоит использовать с осторожностью. Здесь мы поймем какие преимущества он дает и как он может сломать контракт работы с `Stream`.

Вместо отправки события посредством `microtask`, которая вызовет задержку, событие моментально отправляется во всех активных слушателей. Так что если вы понимаете, что асинхронный `StreamController` работает слишком медленно, вы можете посмотреть в сторону синхронной реализации.

А теперь минусы:

1. Асинхронный `Stream` гарантирует, что подписчики смогут получить событие только, когда будут готовы. В синхронном случае, такой гарантии нет, и подписчик может получить событие до того, как будет готов его обработать. Представим, что мы делаем иконку корзины, которая подписывается на источник количества товаров. Источник добавит в `Stream` событие «Теперь в корзине 5 товаров», но иконка ещё не закончила инициализацию и не готова слушать новые события. В синхронном случае, мы потеряем событие и не отобразим счетчик, в асинхронном же Dart гарантирует доставку события.
    
2. `Stream` гарантирует, что события доходят до подписчиков по порядку, и пока предыдущий вызов `add` не отработал полностью, следующее событие не будет отправлено. Синхронный `StreamController` сам не следит за этим, поэтому есть риск нарушить контракт `Stream`.
    

Все повседневные задачи можно решить с помощью асинхронного `StreamController`, так что нужды в синхронном нет. Для более глубокого понимания синхронного `StreamController` советую обратиться к [документации](https://api.flutter.dev/flutter/dart-async/StreamController-class.html).